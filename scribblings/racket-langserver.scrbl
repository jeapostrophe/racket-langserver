#lang scribble/manual
@(require scribble/extract
          (for-label racket
                     (file "../doc.rkt")
                     (file "../interfaces.rkt")))

@title{racket-langserver}

The @tt{racket-langserver} is a @hyperlink["https://langserver.org/"]{Language Server Protocol}
implementation for Racket. This project seeks to use
@seclink[#:indirect? #t #:doc '(lib "scribblings/drracket-tools/drracket-tools.scrbl") "top"]{DrRacket's public APIs}
to provide functionality that mimics DrRacket's code tools as closely as possible.

@section{Installation and usage}

A Racket runtime is a prerequisite, so before using @tt{racket-langserver}, ensure that a Racket runtime
is installed. You can install from the @hyperlink["https://download.racket-lang.org"]{official download page}
or install one from your package manager.

First, install an LSP runtime for your editor.

Next, install the package via @tt{raco}:

@commandline{raco pkg install racket-langserver}

@margin-note{To update the @tt{racket-langserver} use
@commandline{raco pkg update racket-langserver}}

Once it is installed, you can configure your editor to use a custom LSP client for Racket (and all installed
module languages, e.g. Rhombus) files (usually @tt{.rkt}),
and set the command for the custom client to

@commandline{racket -l racket-langserver}

You may need to restart your LSP runtime or your editor for @tt{racket-langserver} to start.

@subsection{VSCode}

Use the @hyperlink["https://marketplace.visualstudio.com/items?itemName=evzen-wybitul.magic-racket"]{Magic Racket} extension.

@section{Interfaces}

@defmodule[racket-langserver/interfaces]

This module provides the data types used by the LSP protocol layer and the doc library API.
Structs defined here are generated by @racket[define-json-struct], which is basically
@racket[struct] with JSON encode/decode support.

Each @racket[define-json-struct] type exports:
@itemlist[
  @item{A keyword constructor / match expander (e.g. @racket[Pos])
        that also accepts positional arguments.}
  @item{A predicate (e.g. @racket[Pos?]).}
  @item{Accessors for each field (e.g. @racket[Pos-line], @racket[Pos-char]).}
  @item{A JSON-hash match expander @tt{Name-js} (e.g. @tt{Pos-js}) that matches
        immutable @racket[hasheq] tables using the JSON field names.}
  @item{A JSON-hash predicate @tt{Name-js?} (e.g. @tt{Pos-js?}).}
]

To convert a struct value to a JSON-compatible @racket[hasheq], use @tt{jsexpr-encode}
from @tt{racket-langserver/json-util}. Nested struct values are encoded recursively.

@subsection{Position and Range}

@defstruct*[Pos ([line exact-nonnegative-integer?]
                 [char exact-nonnegative-integer?])
            #:transparent]{
  LSP position (zero-based line and character offset).
  The JSON field for @tt{char} is @tt{character}.
}

@defstruct*[Range ([start Pos?]
                   [end Pos?])
            #:transparent]{
  LSP half-open range, the character at @tt{end} is excluded.
}

@subsection{Edit Payloads}

@defstruct*[TextEdit ([range Range?]
                      [newText string?])
            #:transparent]{
  A single text replacement operation.
  Apply by replacing the text covered by the @tt{range} field with @tt{newText}.
  Apply edits with @racket[doc-apply-edits!] (including single-edit lists).
  This avoids range-shift pitfalls when multiple edits target nearby offsets.
}

@defstruct*[WorkspaceEdit ([changes (hash/c symbol? (listof TextEdit?))])
            #:transparent]{
  Collection of document edits keyed by document URI.
}

@subsection{Query Responses}

@defstruct*[Location ([uri string?]
                      [range Range?])
            #:transparent]{
  Identifies a source location in a document.
  The @tt{uri} field names the target document, and @tt{range} gives the span
  within that document.
}

@defstruct*[Hover ([contents string?]
                   [range Range?])
            #:transparent]{
  Hover information for a symbol occurrence.
  The @tt{contents} field is Markdown text (typically a type signature plus,
  when available, a link to online documentation).
  The @tt{range} field identifies the source span the hover applies to.
}

@defstruct*[DocumentHighlight ([range Range?])
            #:transparent]{
  Highlight entry for one symbol occurrence.
  The @tt{range} field is the span to highlight in the current document.
}

@defstruct*[CompletionItem ([label string?])
            #:transparent]{
  One completion candidate shown by the client.
  The @tt{label} field is the display text for the candidate.
}

@defstruct*[CompletionList ([isIncomplete boolean?]
                            [items (listof CompletionItem?)])
            #:transparent]{
  Completion response payload.
  The @tt{items} field contains candidate entries.
  The @tt{isIncomplete} field is always @racket[#t], indicating clients should
  continue filtering, sorting and may request updated results as the prefix changes.
}

@defstruct*[SignatureInformation ([label string?]
                                  [documentation string?])
            #:transparent]{
  One call-signature entry in a signature help response.
  The @tt{label} field is the signature text shown to the user.
  The @tt{documentation} field provides additional description for that signature.
}

@defstruct*[SignatureHelp ([signatures (listof SignatureInformation?)])
            #:transparent]{
  Signature help response payload.
  The @tt{signatures} field contains the candidate call signatures for the
  call site, usually one entry per overload.
}

@defstruct*[SymbolInformation ([name string?]
                               [kind exact-positive-integer?]
                               [location Location?])
            #:transparent]{
  One symbol entry in document/workspace symbol results.
  The @tt{name} field is the symbol display name.
  The @tt{kind} field is the LSP symbol kind code.
  The @tt{location} field gives the symbol's source location.
}

@defstruct*[CodeAction ([title string?]
                        [kind string?]
                        [diagnostics (listof Diagnostic?)]
                        [isPreferred boolean?]
                        [edit WorkspaceEdit?])
            #:transparent]{
  One code action returned by a code-action request.
  The @tt{title} field is the user-visible action label.
  The @tt{kind} field is the LSP action kind string (for example quick-fix or refactor).
  The @tt{diagnostics} field lists diagnostics this action addresses.
  The @tt{isPreferred} field marks the preferred action among alternatives.
  The @tt{edit} field is the workspace edit to apply when the action is chosen.
}

@defstruct*[Diagnostic ([range Range?]
                        [severity (or/c 1 2 3 4)]
                        [source string?]
                        [message string?])
            #:transparent]{
  One diagnostic reported to the editor.
  The @tt{range} field identifies the affected source span.
  @tt{severity} values: @racket[1] = error, @racket[2] = warning,
  @racket[3] = information, @racket[4] = hint.
  The @tt{source} field names the producer (for example @tt{racket-langserver}).
  The @tt{message} field is the user-facing diagnostic text.
}

@subsection{Formatting Options}

@defstruct*[FormattingOptions ([tab-size exact-nonnegative-integer?]
                               [insert-spaces boolean?]
                               [trim-trailing-whitespace boolean?]
                               [insert-final-newline boolean?]
                               [trim-final-newlines boolean?]
                               [key (or/c false/c hash?)])
            #:transparent]{
  Formatting options accepted by @racket[doc-format-edits].

  The @tt{tab-size} and @tt{insert-spaces} fields are required in protocol payloads.
  The remaining fields (@tt{trim-trailing-whitespace}, @tt{insert-final-newline},
  @tt{trim-final-newlines}, @tt{key}) are optional in the JSON payload;
  absent fields are represented as an internal @emph{undef} sentinel rather than @racket[#f].
  Test for an absent optional field with @tt{undef?} from @tt{interfaces.rkt}.

  The corresponding JSON field names use camelCase:
  @tt{tabSize}, @tt{insertSpaces}, @tt{trimTrailingWhitespace}, @tt{insertFinalNewline},
  @tt{trimFinalNewlines}.

  Not all generated accessors are exported. Public callers should rely on
  @racket[FormattingOptions-tab-size] and @racket[FormattingOptions-trim-trailing-whitespace].
}

@section{Doc Library}

@defmodule[racket-langserver/doc]

The doc library provides single-threaded document helpers for representing and querying
Racket source documents. All functions operate on document values that satisfy @racket[Doc?]
without touching the network or a thread scheduler, making them suitable for direct testing and reuse.

@subsection[#:tag "doc-state"]{Document State}

@elemtag["doc-type"]{}
@defidform[Doc]{
  Documentation placeholder for the opaque document struct type name.
  Use @racket[Doc?] to test values and @racket[make-doc] to construct them.
}

@deftogether[
  (@defproc[(Doc? [v any/c]) boolean?]
   @defproc[(Doc-uri [doc Doc?]) string?]
   @defproc[(Doc-version [doc Doc?]) exact-nonnegative-integer?])]{
  Predicates and accessors for the opaque @tt{Doc} document value.
  @racket[Doc?] tests whether a value is a document.
  @racket[Doc-uri] returns the document URI string.
  @racket[Doc-version] returns the current nonnegative edit version.
}

@defproc[(make-doc [uri string?]
                  [text string?]
                  [version exact-nonnegative-integer? 0])
         Doc?]{
  Creates a new document state for the given @tt{uri} and initial @tt{text}.
  @tt{version} defaults to @racket[0] and tracks the edit sequence number.
  An initial (empty) @tt{build-trace%} is allocated; call @racket[doc-expand!] to populate it.
}

@defproc[(doc-get-text [doc Doc?]) string?]{
  Returns the full current text content of the document.
}

@defproc[(doc-apply-edits! [doc Doc?]
                           [edits (listof TextEdit?)])
         void?]{
  Applies a list of @racket[TextEdit] values to @tt{doc}.
  Edits are sorted and applied in descending start-position order so earlier edits do not shift
  the offsets of later ones. Raises an error if any two edits overlap.
  The output of @racket[doc-format-edits] can be passed directly to this function if not @racket[#f].
}

@defproc[(doc-reset! [doc Doc?]
                     [new-text string?])
         void?]{
  Replaces the full text with @tt{new-text} and resets internal trace state.
  Use this for whole-file replacements.
}

@defproc[(doc-update-version! [doc Doc?]
                              [new-ver exact-nonnegative-integer?])
         void?]{
  Updates the document's tracked version number.
}

@defproc[(doc-update-uri! [doc Doc?]
                          [new-uri string?])
         void?]{
  Updates the URI associated with the document.
}

@defproc[(doc-copy-text-buffer [doc Doc?]) (is-a?/c lsp-editor%)]{
  Returns a mutable copy of the internal editor buffer.
}

@subsection{Positions and Ranges}

All position helpers below work in terms of absolute character offsets (zero-based integer
indices into the document text) as well as LSP @racket[Pos] structs (line/character pairs).

@defproc[(doc-pos->abs-pos [doc Doc?]
                           [pos Pos?])
         exact-nonnegative-integer?]{
  Converts an LSP @racket[Pos] to an absolute character offset.
}

@defproc[(doc-abs-pos->pos [doc Doc?]
                           [abs-pos exact-nonnegative-integer?])
         Pos?]{
  Converts an absolute character offset to an LSP @racket[Pos].
}

@defproc[(doc-line-start-abs-pos [doc Doc?]
                                 [line exact-nonnegative-integer?])
         exact-nonnegative-integer?]{
  Returns the absolute character offset at the start of @tt{line} (zero-based).
}

@defproc[(doc-line-end-abs-pos [doc Doc?]
                               [line exact-nonnegative-integer?])
         exact-nonnegative-integer?]{
  Returns the absolute character offset at the end of @tt{line},
  not including the newline character.
}

@defproc[(doc-end-abs-pos [doc Doc?]) exact-nonnegative-integer?]{
  Returns the absolute character offset one past the last character.
}

@defproc[(doc-find-containing-paren [doc Doc?]
                                    [pos exact-nonnegative-integer?])
         (or/c exact-nonnegative-integer? #f)]{
  Scans backward from @tt{pos} and returns the absolute offset of the nearest
  unmatched opening parenthesis or bracket (@tt{(} or @tt{[}), or @racket[#f] if
  none is found.
  This is a character-level heuristic, not a full parse.
}

@subsection{Trace and Semantic Operations}

These functions wrap check-syntax expansion and analysis.

@defproc[(doc-expand! [doc Doc?]) boolean?]{
  Convenience wrapper: expands the document in-place, updates its trace to the newest
  version, and walks the expanded text. Returns @racket[#t] on success,
  @racket[#f] if check-syntax expansion failed (e.g., the file has syntax errors).
  Query results from functions below are fully functional only when this returns @racket[#t].
  The query functions probably return useful results without expand.
}

@defproc[(doc-update-trace! [doc Doc?]
                             [new-trace (is-a?/c build-trace%)]
                             [new-version exact-nonnegative-integer?])
         void?]{
  Replaces the document's trace with a freshly computed one. Called internally by
  @racket[doc-expand!] but also useful when a scheduler provides a new trace externally.
}

@defproc[(doc-trace-latest? [doc Doc?]) boolean?]{
  Returns @racket[#t] if the trace version matches the current document version,
  meaning the trace is up to date and query results are reliable.
}

@defproc[(doc-walk-text [trace (is-a?/c build-trace%)]
                        [text string?])
         void?]{
  Feeds @tt{text} into @racket[trace] for incremental token and hover collection.
  Called automatically by @racket[doc-expand!].
}

@defproc[(doc-get-symbols [doc Doc?])
         (interval-map-of (list/c string? (or/c 'constant 'string 'symbol)))]{
  Returns a lexer-derived interval map of symbol, string, and constant token intervals
  for the current document. Each entry maps a @tt{[start, end)} range to a
  @racket[(list text type)] pair where @tt{text} is the token's string representation
  and @tt{type} is one of @racket['constant], @racket['string], or @racket['symbol].
  Positions are absolute character offsets. Does not require an up-to-date trace.
}

@defproc[(doc-range-tokens [doc Doc?]
                           [range Range?])
         (listof exact-nonnegative-integer?)]{
  Returns LSP semantic token data for tokens that intersect @tt{range}.
  The result is a flat integer list in repeated 5-value groups:
  @racketblock[(deltaLine deltaStart length tokenType tokenModifiers)].
  So the full shape is:

  @racketblock[
    (list deltaLine deltaStart length tokenType tokenModifiers
          deltaLine deltaStart length tokenType tokenModifiers
          ...)
  ]

  Encodings follow LSP 3.17:
  @tt{deltaLine} and @tt{deltaStart} are relative to the previous token,
  @tt{length} is token character length.
}

@defproc[(doc-guess-token [doc Doc?]
                          [pos exact-nonnegative-integer?])
         string?]{
  Heuristically extracts a token-like prefix ending at absolute offset @tt{pos}
  by scanning backward until a quote or whitespace character is encountered.
  Used for completion prefix matching. This is a character-level approximation;
  it does not use the lexer.
}

@subsection{Query Functions}

These return structured LSP responses. They all require an up-to-date trace;
call @racket[doc-expand!] first or check @racket[doc-trace-latest?].

@defproc[(doc-hover [doc Doc?]
                    [pos Pos?])
         (or/c Hover? #f)]{
  Returns hover info at @tt{pos}, including the identifier's type signature
  and a link to online documentation, or @racket[#f] if nothing is found.
}

@defproc[(doc-completion [doc Doc?]
                         [pos Pos?])
         CompletionList?]{
  Returns completion candidates at @tt{pos}. The list is always marked incomplete
  (@tt{isIncomplete} is @racket[#t]) since filtering is delegated to the client.
}

@defproc[(doc-definition [doc Doc?]
                         [uri string?]
                         [pos Pos?])
         (or/c Location? #f)]{
  Resolves the definition location for the identifier at @tt{pos}.
  Returns a @racket[Location] in the same file for local bindings, a @racket[Location]
  in the external file for required identifiers (triggering a cross-file check-syntax
  expansion), or @racket[#f] if not found.
}

@defproc[(doc-references [doc Doc?]
                         [uri string?]
                         [pos Pos?]
                         [include-decl? boolean?])
         (or/c (listof Location?) #f)]{
  Returns all reference locations for the identifier at @tt{pos}, or @racket[#f]
  if no binding is found.

  @margin-note{The @tt{include-decl?} parameter is accepted for API compatibility
  with the LSP protocol but is not currently used in the implementation; the declaration
  site is always included when the binding is in the same file.}
}

@defproc[(doc-highlights [doc Doc?]
                         [pos Pos?])
         (or/c (listof DocumentHighlight?) #f)]{
  Returns document highlight entries for all occurrences of the symbol at @tt{pos},
  or @racket[#f] if no binding is found.
}

@defproc[(doc-rename [doc Doc?]
                     [uri string?]
                     [pos Pos?]
                     [new-name string?])
         (or/c WorkspaceEdit? #f)]{
  Builds a workspace edit that renames all occurrences of the identifier at @tt{pos}
  to @tt{new-name}. Returns @racket[#f] if the identifier cannot be renamed (e.g.,
  it is imported from another module).
}

@defproc[(doc-prepare-rename [doc Doc?]
                             [pos Pos?])
         (or/c Range? #f)]{
  Returns the range of the renameable identifier at @tt{pos}, or @racket[#f] if the
  identifier cannot be renamed (e.g., it is an external binding).
}

@defproc[(doc-signature-help [doc Doc?]
                             [pos Pos?])
         (or/c SignatureHelp? #f)]{
  Returns signature help for the function call enclosing @tt{pos} by scanning
  backward for the nearest opening parenthesis, or @racket[#f] if not inside a call.
}

@defproc[(doc-code-action [doc Doc?]
                          [range Range?])
         (listof CodeAction?)]{
  Returns quick-fix code actions available at the start of @tt{range}.
  Returns an empty list when no actions are available.
}

@defproc[(doc-symbols [doc Doc?]
                      [uri string?])
         (listof SymbolInformation?)]{
  Returns all lexer-visible symbol, string, and constant occurrences in the document
  as @racket[SymbolInformation] values with their source locations.
  Does not require an up-to-date trace; it runs the lexer directly over the current text.
}


@subsection{Formatting}

@defproc[(doc-format-edits [doc Doc?]
                      [fmt-range Range?]
                      [#:on-type? on-type? boolean? #f]
                      [#:formatting-options opts FormattingOptions?])
         (or/c (listof TextEdit?) #f)]{
  Computes formatting edits for the lines covered by @tt{fmt-range}.
  Returns a list of @racket[TextEdit] values to apply, or @racket[#f] if no
  indenter is available (e.g., the document lacks a @tt{#lang} line).

  When @tt{on-type?} is @racket[#t], blank lines are indented too. This mode is used for
  on-type formatting triggered by pressing Enter.

  The result list can be applied directly with @racket[doc-apply-edits!].
  The formatting is performed on an internal copy of the document, so the doc is not
  mutated by this call; mutation only happens when the caller passes the result to
  @racket[doc-apply-edits!].
}
